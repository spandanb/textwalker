<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>textwalker.pattern_parser API documentation</title>
<meta name="description" content="Contains classes for parsing pattern and matching text against the pattern" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textwalker.pattern_parser</code></h1>
</header>
<section id="section-intro">
<p>Contains classes for parsing pattern and matching text against the pattern</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contains classes for parsing pattern and matching text against the pattern
&#34;&#34;&#34;
from typing import List, Optional

from .utils import arr2str

# Globals

ESCAPABLE_CHARS = {&#34;(&#34;, &#34;)&#34;, &#34;[&#34;, &#34;]&#34;, &#34;{&#34;, &#34;}&#34;, &#34;-&#34;}


# Exceptions


class UnescapedChar(Exception):
    &#34;&#34;&#34;
    These represent the constraint that special chars be escaped
    &#34;&#34;&#34;

    pass


class UnescapedDash(UnescapedChar):
    &#34;&#34;&#34;
    A dash character was unescaped
    &#34;&#34;&#34;

    pass


class UnrecognizedEscapedChar(Exception):
    &#34;&#34;&#34;
    This represents that random characters should not be escaped
    &#34;&#34;&#34;

    pass


class UnclosedCharSet(Exception):
    &#34;&#34;&#34;
    A char set was not closed, i.e. missing &#39;]&#39;
    &#34;&#34;&#34;

    pass


# Quantifier classes


class Quantifier:
    &#34;&#34;&#34;
    base quantifier class
    &#34;&#34;&#34;

    pass


class ZeroOrMore(Quantifier):
    &#34;&#34;&#34;
    Represents quantifier zero or more repetitions
    &#34;&#34;&#34;

    def __str__(self):
        return &#34;*&#34;


class OneOrMore(Quantifier):
    &#34;&#34;&#34;
    Represents quantifier one or more repetitions
    &#34;&#34;&#34;

    def __str__(self):
        return &#34;+&#34;

    def __repr__(self):
        return str(self)


class ZeroOrOne(Quantifier):
    &#34;&#34;&#34;
    Represents quantifier zero or one repetitions
    &#34;&#34;&#34;

    def __str__(self):
        return &#34;?&#34;


class Token:
    &#34;&#34;&#34;
    base token type
    &#34;&#34;&#34;

    def __init__(self, quantifier=None):
        self.quantifier = quantifier


class Literal(Token):
    &#34;&#34;&#34;
    Represents a literal token
    &#34;&#34;&#34;

    def __init__(self, value, quantifier=None):
        super().__init__(quantifier)
        self.value = value

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;L[{self.value}{self.quantifier}]&#34;
        return f&#34;L[{self.value}]&#34;

    def __str__(self):
        return self.__repr__()


class CharRange(Token):
    &#34;&#34;&#34;
    Represents a child range in a charset, e.g. a-z
    &#34;&#34;&#34;

    def __init__(self, range_start, range_end, quantifier=None):
        super().__init__(quantifier)
        self.range_start = range_start
        self.range_end = range_end

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;CR[{self.range_start}-{self.range_end}{self.quantifier}]&#34;
        return f&#34;CR({self.range_start}-{self.range_end})&#34;

    def __str__(self):
        return self.__repr__()


class Charset(Token):
    &#34;&#34;&#34;
    Represents a charset e.g. [a-z01]
    &#34;&#34;&#34;

    def __init__(self, matches: list, quantifier=None):
        super().__init__(quantifier)
        # matches is composed of either literals or ranges
        self.matches = matches

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;CS[{self.matches}{self.quantifier}]&#34;
        return f&#34;CS[{self.matches}]&#34;

    def __str__(self):
        return self.__repr__()


class Grouping(Token):
    &#34;&#34;&#34;
    Represents a grouping e.g. (foo)
    &#34;&#34;&#34;

    def __init__(self, groups: list, quantifier=None):
        self.groups = groups
        super().__init__(quantifier)

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;G[{self.groups}{self.quantifier}]&#34;
        return f&#34;G[{self.groups}]&#34;


class MatchResult:
    &#34;&#34;&#34;
    Result for match
    &#34;&#34;&#34;

    def __init__(self, matched: bool, content: str = &#34;&#34;):
        self.matched = matched
        self.content = content

    def __str__(self):
        if self.matched is False:
            return &#34;NoMatch&#34;
        return f&#34;Match({self.content})&#34;

    def __repr__(self):
        return str(self)


class PatternParser:
    &#34;&#34;&#34;
    Class responsible for parsing logic.
    &#34;&#34;&#34;

    def __init__(self, pattern: str):
        # when parsing a chunk, `start` is the start of the chunk
        # and `current` points to the `current` char
        self.start = 0
        self.current = 0
        self.pattern = pattern
        self.compiled = None
        self.compile()

    def is_at_end(self) -&gt; bool:
        &#34;&#34;&#34;
        Determine whether parser is at the end of the pattern text
        &#34;&#34;&#34;
        return self.current &gt;= len(self.pattern)

    def advance(self) -&gt; str:
        &#34;&#34;&#34;
        Consume and return the current char.
        Consumption increments `current`
        &#34;&#34;&#34;
        char = self.pattern[self.current]
        self.current += 1
        return char

    def has_next(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether there is a next element to consume
        &#34;&#34;&#34;
        return self.current &lt; len(self.pattern) - 1

    def has_next_next(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether there is a next to next element to consume
        &#34;&#34;&#34;
        return self.current &lt; len(self.pattern) - 2

    def peek(self) -&gt; str:
        &#34;&#34;&#34;
        View the current element without consuming it
        &#34;&#34;&#34;
        return self.pattern[self.current]

    def peek_next(self) -&gt; str:
        &#34;&#34;&#34;
        View the next element without consuming it.
        NOTE: This call is only valid if `has_next` is True
        &#34;&#34;&#34;
        return self.pattern[self.current + 1]

    def peek_next_next(self) -&gt; str:
        &#34;&#34;&#34;
        View the next to next element without consuming it
        NOTE: This call is only valid if `has_next_next` is True
        &#34;&#34;&#34;
        return self.pattern[self.current + 2]

    @staticmethod
    def coalesce_literals(tokens: List[Token]) -&gt; List[Token]:
        &#34;&#34;&#34;
        Combine adjacent literal chars with no quantifier into a literal word;
        e.g. L[a]L[b] -&gt; L[ab]

        This is needed because the parsing pass, does not peek to the next
        char and treats each char as a single-char literal. This coalescing is needed
        to match word level repetitions.

        The relative ordering of non-`Literal` tokens and `Literal` tokens with
        quantifiers is unchanged.
        &#34;&#34;&#34;

        coalesced = []
        partials = (
            []
        )  # partial list of chars that will be coalesced into in a single Literal
        for idx, token in enumerate(tokens):
            # if quantifier is not None, can&#39;t coalesce into one literal
            if isinstance(token, Literal) and token.quantifier is None:
                partials.append(token)
            elif len(partials) &gt; 0:
                # we&#39;re at coalesce boundary; coalesce `partials` into a single
                # Literal and add to result
                value = &#34;&#34;.join([literal.value for literal in partials])
                coalesced.append(Literal(value))
                partials = []

            # add all other tokens, as-is
            if (
                not isinstance(token, Literal)
                or isinstance(token, Literal)
                and token.quantifier is not None
            ):
                coalesced.append(token)

        if len(partials) &gt; 0:
            # add remaining chars as a literal
            value = &#34;&#34;.join([literal.value for literal in partials])
            coalesced.append(Literal(value))
        return coalesced

    def compile(self):
        &#34;&#34;&#34;
        compile the user supplied pattern
        &#34;&#34;&#34;
        if self.compiled is None:
            self.compiled = self.compile_grouping()

    def compile_subgroups(self, subgroups: List[Token]) -&gt; Token:
        &#34;&#34;&#34;
        Compile subgroups.

        When compiling a pattern, a pattern may consist of
        one or more subgroups. If there is a single sub-group, return
        the subgroup as is. This is needed to avoid excessive nesting,
        which leads to incorrect behavior. If there are multiple sub-groups, then
        wrap them in a coalesced `Grouping`
        &#34;&#34;&#34;
        coalesced = self.coalesce_literals(subgroups)
        if len(coalesced) == 1:
            # return single sub group as is
            return coalesced.pop()
        # wrap multiple sub-groups in a grouping
        return Grouping(coalesced)

    def compile_grouping(self, is_nested: bool = False) -&gt; Grouping:
        &#34;&#34;&#34;
        Compile the pattern/grouping. A grouping consists of any number of
        literals, charsets, and sub-groups, and is the most general
        representation of a pattern. Hence, the user input is treated as a `Grouping`

        args:
            is_nested: whether this is nested grouping

        pattern can be of form:
        foo  : literal
        [a-z]: charset (range)
        [3-9]
        [az] charsets (enumeration)
        fox* : single-char quantifier: *,+,?
        [3-9]{3,4}: quantity/numeric range
        (foo)*: groupings
        (foo_[a-z]*)+: groupings

        NB: quantifiers can apply to any other element, except another quantifier

        special chars, namely:
            -, {, }, [, ], *, +, ?, (, ) must be escaped

        escape via backslash prepended to char

        An unescaped special char is an error

        An escaped char, that should not be escaped in an error.

        Returns:
            compiled grouping; for the root call this is a `Grouping`
            object; for a non-root call this could be any other `Token`
        &#34;&#34;&#34;
        compiled = []
        while self.is_at_end() is False:
            ch = self.advance()
            if ch == &#34;(&#34;:
                # handle grouping
                grouping = self.compile_grouping(is_nested=True)
                compiled.append(grouping)
            elif ch == &#34;)&#34;:
                if is_nested:
                    # this terminates the grouping
                    return self.compile_subgroups(compiled)
                raise UnescapedChar(&#34;)&#34;)
            elif ch == &#34;[&#34;:
                # this will either succeed and consume and return
                # entire charset, or raise exception
                charset = self.compile_charset()
                compiled.append(charset)
            # handle quantifiers
            elif ch == &#34;*&#34; or ch == &#34;+&#34; or ch == &#34;?&#34;:
                # find matchable to attach quantifier to
                matchable = compiled[-1] if len(compiled) &gt; 0 else None
                if matchable is None:
                    raise UnescapedChar
                if ch == &#34;*&#34;:
                    matchable.quantifier = ZeroOrMore()
                elif ch == &#34;+&#34;:
                    matchable.quantifier = OneOrMore()
                else:
                    assert ch == &#34;?&#34;, &#34;unknown quantifier&#34;
                    matchable.quantifier = ZeroOrOne()
            elif ch == &#34;{&#34;:
                # this will either succeed and consume the entire quantifier or raise
                # TODO: implememt me
                raise NotImplementedError
            # handle escape char
            elif ch == &#34;\\&#34;:
                next_char = self.advance()
                if next_char not in ESCAPABLE_CHARS:
                    # NOTE: currently not supporting all escape chars
                    raise UnrecognizedEscapedChar
                # add the escaped char as a literal
                compiled.append(Literal(next_char))

            else:
                compiled.append(Literal(ch))

        if is_nested:
            # this is error; since this was a nested call we should have found
            # a closing bracket; the choice of exception is imprecise
            # because the user&#39;s intention could be to: 1) create a group
            # and perhaps forgot the closing bracket; or 2) a literal match
            # on open bracket &#34;(&#34; and forgot to escape; for now bracket &#34;(&#34; must be escaped
            raise UnescapedChar(&#34;Unclosed bracket&#34;)

        grouping = self.compile_subgroups(compiled)
        if not is_nested and not isinstance(grouping, Grouping):
            # this is the root call- the returned must be wrapped in a grouping
            grouping = Grouping([grouping])
        return grouping

    def compile_charset(self) -&gt; Charset:
        &#34;&#34;&#34;
        Consume characters in the pattern, corresponding to a charset,
        i.e. started with &#39;[&#39;, terminated with &#39;]&#39; with literals and char ranges
        in between.

        Returns:
            compiled `Charset`

        Raises:
            - UnclosedSet and unescapedDash
        &#34;&#34;&#34;
        result = []
        closed = False  # whether the charset is closed
        while self.is_at_end() is False:
            ch = self.advance()  # consume char
            # handle escape char
            if ch == &#34;\\&#34;:
                next_char = self.advance()
                if next_char not in ESCAPABLE_CHARS:
                    # NOTE: currently not supporting all escape chars
                    raise UnrecognizedEscapedChar
                # add the escaped char as a literal
                result.append(Literal(next_char))

            # handle range dash
            if ch == &#34;-&#34;:
                # an unescaped dash, should only appear between a range
                # this simplifies the case, where it&#39;s the first or last char in set
                raise UnescapedDash
            if ch == &#34;]&#34;:
                # closing bracket found
                closed = True
                break
            else:  # ch is non-special
                # check if it&#39;s part of a range
                if self.has_next() and self.peek() == &#34;-&#34;:
                    if not self.has_next_next():
                        # unescaped dash&#39;s are only supported in range
                        raise UnescapedDash
                    self.advance()  # consume the dash
                    rng_end = self.advance()
                    rng = CharRange(ch, rng_end)
                    result.append(rng)
                else:  # handle literal
                    result.append(Literal(ch))
        if not closed:
            raise UnclosedCharSet()

        return Charset(result)

    def match(self, string: str, startidx: int = 0) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Attempt to match `string` starting at `startidx`
        Args:
            string: string to match
            startidx: location to start search
        Return
            None: no-match
            str: match (possibly zero length)
        &#34;&#34;&#34;
        matcher = PatternMatcher(self.compiled)
        return matcher.match(string, startidx)


class PatternMatcher:
    &#34;&#34;&#34;
    Encapsulates pattern matching logic
    &#34;&#34;&#34;

    def __init__(self, compiled: Grouping):
        self.compiled = compiled

    @staticmethod
    def can_consume(to_run_iteration: int, quantifier: Quantifier) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether the `quantifier` allows consuming another repetition
        NOTE: this should be invoked before consuming
        &#34;&#34;&#34;
        if isinstance(quantifier, ZeroOrMore) or isinstance(quantifier, OneOrMore):
            return True
        elif isinstance(quantifier, ZeroOrOne):
            return to_run_iteration &lt; 1
        elif quantifier is None:
            # interpret None as 1
            return to_run_iteration &lt; 1
        return True

    @staticmethod
    def sufficient_consumed(last_repetition: int, quantifier: Quantifier) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether the minimum number of elements was consumed
        NOTE: this should be invoked after consuming
        &#34;&#34;&#34;
        if isinstance(quantifier, ZeroOrOne):
            return True
        elif isinstance(quantifier, ZeroOrMore):
            return True
        elif isinstance(quantifier, OneOrMore):
            return last_repetition &gt;= 1
        elif quantifier is None:
            # TODO: not sure if this correct
            return True
        else:
            return True

    @staticmethod
    def accepts_empty(quantifier: Quantifier) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether the quantifier allows for an empty match
        &#34;&#34;&#34;
        # TODO: add check for quantity range
        return isinstance(quantifier, ZeroOrMore) or isinstance(quantifier, ZeroOrOne)

    def check_and_update_empty(
        self, result: MatchResult, quantifier: Quantifier
    ) -&gt; MatchResult:
        &#34;&#34;&#34;
        In cases where the quantifier, permits 0 matches, e.g. *, ?,
        a &#34;no-match&#34; of a sub-group is to be treated as a match of length zero.

        Returns:
            If there is a no-match, and the quantifier allows zero matches,
            then this will update the result to be an empty match;
            Otherwise, it will return the `result`
        &#34;&#34;&#34;
        # if quantifier is [0,..] and no-match, this is treated
        # as a match of len 0;
        if result.matched is False and self.accepts_empty(quantifier):
            result = MatchResult(True, &#34;&#34;)
        # else return original result
        return result

    @staticmethod
    def match_literal(literal: Literal, string: str, stridx: int = 0) -&gt; MatchResult:
        &#34;&#34;&#34;
        Attempt to match a literal
        &#34;&#34;&#34;
        for idx, lch in enumerate(literal.value):
            if stridx + idx == len(string):
                return MatchResult(False)
            if lch != string[stridx + idx]:
                return MatchResult(False)
        return MatchResult(True, literal.value)

    @staticmethod
    def match_charset(charset: Charset, string: str, stridx: int = 0) -&gt; MatchResult:
        &#34;&#34;&#34;
        Attempt to match a charset
        &#34;&#34;&#34;
        for charset_member in charset.matches:
            if stridx == len(string):
                # handle empty string
                return MatchResult(False)
            if isinstance(charset_member, Literal):
                if charset_member.value == string[stridx]:
                    return MatchResult(True, string[stridx])
            elif isinstance(charset_member, CharRange):
                # NOTE: this comparison relies on python&#39;s lexical ordering
                if (
                    charset_member.range_start
                    &lt;= string[stridx]
                    &lt;= charset_member.range_end
                ):
                    return MatchResult(True, string[stridx])
        return MatchResult(False)

    def match_sub_groups(self, groups: List[Token], string: str, stridx: int = 0):
        &#34;&#34;&#34;
        Attempt to match a list of sub groups.
        &#34;&#34;&#34;
        sgptr = 0  # sub-group ptr
        sgroup_repetition = 0  # count of repetitions of current sub group
        matched = []
        # the last gptr location where a match was found
        # needed to determine if the pattern was fully consumed
        last_matched_sgptr = -1

        while sgptr &lt; len(groups):

            # there are 2 things to check:
            # 1) is there a match
            # 2) is the number of repetitions of match as expected

            # consume as much of string (maximum munch) using subgroup
            subgroup = groups[sgptr]

            # does the quantifier on this subgroup, allow it to consume more chars
            if self.can_consume(sgroup_repetition, subgroup.quantifier):

                # invoke the right handler
                res = None
                if isinstance(subgroup, Literal):
                    res = self.match_literal(subgroup, string, stridx)
                    res = self.check_and_update_empty(res, subgroup.quantifier)
                elif isinstance(subgroup, Charset):
                    res = self.match_charset(subgroup, string, stridx)
                    res = self.check_and_update_empty(res, subgroup.quantifier)
                else:
                    assert isinstance(
                        subgroup, Grouping
                    ), &#34;unexpected sub-expression type&#34;
                    # groupings can be nested
                    # so the matching algorithm must be recursive
                    res = self.match_grouping(subgroup, string, stridx)
                    res = self.check_and_update_empty(res, subgroup.quantifier)

                # current component matched
                if res.matched:
                    sgroup_repetition += 1
                    matched.append(res.content)
                    # increment string pointer
                    stridx += len(res.content)
                    last_matched_sgptr = sgptr

                    # increment the gptr; this represents
                    # something not matching with [0,...] quantifier
                    # we treat this as a match of length 0
                    if len(res.content) == 0:
                        sgptr += 1
                        sgroup_repetition = 0

                # current component did not match
                else:
                    # no match, move to next matchable
                    # check minimum match cond was violated
                    if not self.sufficient_consumed(
                        sgroup_repetition, subgroup.quantifier
                    ):
                        # raise MinMatchesNotFound
                        return MatchResult(False)

                    sgroup_repetition = 0
                    # increment component pointer
                    sgptr += 1
            else:
                # quantifier restricts further consume
                # consider next subgroup
                sgptr += 1
                sgroup_repetition = 0
                continue

        # we want the pattern to be fully consumed and at least one
        # group has not been matched
        if last_matched_sgptr &lt; len(groups) - 1:
            return MatchResult(False)

        content = arr2str(matched)
        return MatchResult(True, content)

    def match_grouping(
        self, grouping: Grouping, string: str, stridx: int = 0
    ) -&gt; MatchResult:
        &#34;&#34;&#34;
        Finds the longest match by greedily matching characters.
        Greedy here implies, that when matching text on a sub-group, it will consume
        as many characters from the text, as the sub-group can match. This is
        noteworthy since a non-greedy sub-group match may result in a overall pattern match; whereas
        the greedy approach results in a non-match; e.g.:

        for pattern = (aa)*a, text = aaaa, the greedy algorithm would consider this a
        non-match since, the pattern must be fully consumed, and the final &#39;a&#39; does not get
        consumed.

        The user string may be partially consumed. However, if the pattern
        is not consumed, then this is considered a non-match.

        An empty string is a valid input to match. Further an empty string can
        match an arbitrary pattern, as long as each child pattern allows
        zero matches. Thus all matching handlers must handle zero-length input string

        Args:
            stridx: idx where to start matching string

        Returns:
            MatchResult.matched is True if there is a complete match; else False
        &#34;&#34;&#34;

        groups = grouping.groups

        group_repetition = 0  # count of repetitions of group
        matched = []  # chars that have matched
        sg_matched = True
        while self.can_consume(group_repetition, grouping.quantifier):
            res = self.match_sub_groups(groups, string, stridx)
            if res.matched:
                matched.append(res.content)
                group_repetition += 1
                stridx += len(res.content)
                if len(res.content) == 0:
                    break
            else:
                sg_matched = False
                break

        content = arr2str(matched)
        # the following distinguishes a non-match from an empty match
        # i.e. content length is 0 and the quantifier does not allow a zero match
        if (len(content) == 0 and sg_matched is False) and self.accepts_empty(
            grouping.quantifier
        ) is False:
            return MatchResult(False)

        return MatchResult(True, content)

    def match(self, string: str, stridx: int = 0) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Attempt to match `string` starting at `startidx`
        Args:
            string: string to match
            startidx: location to start search
        Return
            None: no-match
            str: match (possibly zero length)
        &#34;&#34;&#34;
        matched = None
        result = self.match_grouping(self.compiled, string, stridx)
        if result.matched:
            matched = result.content
        return matched</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textwalker.pattern_parser.CharRange"><code class="flex name class">
<span>class <span class="ident">CharRange</span></span>
<span>(</span><span>range_start, range_end, quantifier=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a child range in a charset, e.g. a-z</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CharRange(Token):
    &#34;&#34;&#34;
    Represents a child range in a charset, e.g. a-z
    &#34;&#34;&#34;

    def __init__(self, range_start, range_end, quantifier=None):
        super().__init__(quantifier)
        self.range_start = range_start
        self.range_end = range_end

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;CR[{self.range_start}-{self.range_end}{self.quantifier}]&#34;
        return f&#34;CR({self.range_start}-{self.range_end})&#34;

    def __str__(self):
        return self.__repr__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.Charset"><code class="flex name class">
<span>class <span class="ident">Charset</span></span>
<span>(</span><span>matches: list, quantifier=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a charset e.g. [a-z01]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Charset(Token):
    &#34;&#34;&#34;
    Represents a charset e.g. [a-z01]
    &#34;&#34;&#34;

    def __init__(self, matches: list, quantifier=None):
        super().__init__(quantifier)
        # matches is composed of either literals or ranges
        self.matches = matches

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;CS[{self.matches}{self.quantifier}]&#34;
        return f&#34;CS[{self.matches}]&#34;

    def __str__(self):
        return self.__repr__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.Grouping"><code class="flex name class">
<span>class <span class="ident">Grouping</span></span>
<span>(</span><span>groups: list, quantifier=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a grouping e.g. (foo)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grouping(Token):
    &#34;&#34;&#34;
    Represents a grouping e.g. (foo)
    &#34;&#34;&#34;

    def __init__(self, groups: list, quantifier=None):
        self.groups = groups
        super().__init__(quantifier)

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;G[{self.groups}{self.quantifier}]&#34;
        return f&#34;G[{self.groups}]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.Literal"><code class="flex name class">
<span>class <span class="ident">Literal</span></span>
<span>(</span><span>value, quantifier=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a literal token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Literal(Token):
    &#34;&#34;&#34;
    Represents a literal token
    &#34;&#34;&#34;

    def __init__(self, value, quantifier=None):
        super().__init__(quantifier)
        self.value = value

    def __repr__(self):
        if self.quantifier is not None:
            return f&#34;L[{self.value}{self.quantifier}]&#34;
        return f&#34;L[{self.value}]&#34;

    def __str__(self):
        return self.__repr__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.MatchResult"><code class="flex name class">
<span>class <span class="ident">MatchResult</span></span>
<span>(</span><span>matched: bool, content: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Result for match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatchResult:
    &#34;&#34;&#34;
    Result for match
    &#34;&#34;&#34;

    def __init__(self, matched: bool, content: str = &#34;&#34;):
        self.matched = matched
        self.content = content

    def __str__(self):
        if self.matched is False:
            return &#34;NoMatch&#34;
        return f&#34;Match({self.content})&#34;

    def __repr__(self):
        return str(self)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.OneOrMore"><code class="flex name class">
<span>class <span class="ident">OneOrMore</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents quantifier one or more repetitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OneOrMore(Quantifier):
    &#34;&#34;&#34;
    Represents quantifier one or more repetitions
    &#34;&#34;&#34;

    def __str__(self):
        return &#34;+&#34;

    def __repr__(self):
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher"><code class="flex name class">
<span>class <span class="ident">PatternMatcher</span></span>
<span>(</span><span>compiled: <a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Encapsulates pattern matching logic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PatternMatcher:
    &#34;&#34;&#34;
    Encapsulates pattern matching logic
    &#34;&#34;&#34;

    def __init__(self, compiled: Grouping):
        self.compiled = compiled

    @staticmethod
    def can_consume(to_run_iteration: int, quantifier: Quantifier) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether the `quantifier` allows consuming another repetition
        NOTE: this should be invoked before consuming
        &#34;&#34;&#34;
        if isinstance(quantifier, ZeroOrMore) or isinstance(quantifier, OneOrMore):
            return True
        elif isinstance(quantifier, ZeroOrOne):
            return to_run_iteration &lt; 1
        elif quantifier is None:
            # interpret None as 1
            return to_run_iteration &lt; 1
        return True

    @staticmethod
    def sufficient_consumed(last_repetition: int, quantifier: Quantifier) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether the minimum number of elements was consumed
        NOTE: this should be invoked after consuming
        &#34;&#34;&#34;
        if isinstance(quantifier, ZeroOrOne):
            return True
        elif isinstance(quantifier, ZeroOrMore):
            return True
        elif isinstance(quantifier, OneOrMore):
            return last_repetition &gt;= 1
        elif quantifier is None:
            # TODO: not sure if this correct
            return True
        else:
            return True

    @staticmethod
    def accepts_empty(quantifier: Quantifier) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether the quantifier allows for an empty match
        &#34;&#34;&#34;
        # TODO: add check for quantity range
        return isinstance(quantifier, ZeroOrMore) or isinstance(quantifier, ZeroOrOne)

    def check_and_update_empty(
        self, result: MatchResult, quantifier: Quantifier
    ) -&gt; MatchResult:
        &#34;&#34;&#34;
        In cases where the quantifier, permits 0 matches, e.g. *, ?,
        a &#34;no-match&#34; of a sub-group is to be treated as a match of length zero.

        Returns:
            If there is a no-match, and the quantifier allows zero matches,
            then this will update the result to be an empty match;
            Otherwise, it will return the `result`
        &#34;&#34;&#34;
        # if quantifier is [0,..] and no-match, this is treated
        # as a match of len 0;
        if result.matched is False and self.accepts_empty(quantifier):
            result = MatchResult(True, &#34;&#34;)
        # else return original result
        return result

    @staticmethod
    def match_literal(literal: Literal, string: str, stridx: int = 0) -&gt; MatchResult:
        &#34;&#34;&#34;
        Attempt to match a literal
        &#34;&#34;&#34;
        for idx, lch in enumerate(literal.value):
            if stridx + idx == len(string):
                return MatchResult(False)
            if lch != string[stridx + idx]:
                return MatchResult(False)
        return MatchResult(True, literal.value)

    @staticmethod
    def match_charset(charset: Charset, string: str, stridx: int = 0) -&gt; MatchResult:
        &#34;&#34;&#34;
        Attempt to match a charset
        &#34;&#34;&#34;
        for charset_member in charset.matches:
            if stridx == len(string):
                # handle empty string
                return MatchResult(False)
            if isinstance(charset_member, Literal):
                if charset_member.value == string[stridx]:
                    return MatchResult(True, string[stridx])
            elif isinstance(charset_member, CharRange):
                # NOTE: this comparison relies on python&#39;s lexical ordering
                if (
                    charset_member.range_start
                    &lt;= string[stridx]
                    &lt;= charset_member.range_end
                ):
                    return MatchResult(True, string[stridx])
        return MatchResult(False)

    def match_sub_groups(self, groups: List[Token], string: str, stridx: int = 0):
        &#34;&#34;&#34;
        Attempt to match a list of sub groups.
        &#34;&#34;&#34;
        sgptr = 0  # sub-group ptr
        sgroup_repetition = 0  # count of repetitions of current sub group
        matched = []
        # the last gptr location where a match was found
        # needed to determine if the pattern was fully consumed
        last_matched_sgptr = -1

        while sgptr &lt; len(groups):

            # there are 2 things to check:
            # 1) is there a match
            # 2) is the number of repetitions of match as expected

            # consume as much of string (maximum munch) using subgroup
            subgroup = groups[sgptr]

            # does the quantifier on this subgroup, allow it to consume more chars
            if self.can_consume(sgroup_repetition, subgroup.quantifier):

                # invoke the right handler
                res = None
                if isinstance(subgroup, Literal):
                    res = self.match_literal(subgroup, string, stridx)
                    res = self.check_and_update_empty(res, subgroup.quantifier)
                elif isinstance(subgroup, Charset):
                    res = self.match_charset(subgroup, string, stridx)
                    res = self.check_and_update_empty(res, subgroup.quantifier)
                else:
                    assert isinstance(
                        subgroup, Grouping
                    ), &#34;unexpected sub-expression type&#34;
                    # groupings can be nested
                    # so the matching algorithm must be recursive
                    res = self.match_grouping(subgroup, string, stridx)
                    res = self.check_and_update_empty(res, subgroup.quantifier)

                # current component matched
                if res.matched:
                    sgroup_repetition += 1
                    matched.append(res.content)
                    # increment string pointer
                    stridx += len(res.content)
                    last_matched_sgptr = sgptr

                    # increment the gptr; this represents
                    # something not matching with [0,...] quantifier
                    # we treat this as a match of length 0
                    if len(res.content) == 0:
                        sgptr += 1
                        sgroup_repetition = 0

                # current component did not match
                else:
                    # no match, move to next matchable
                    # check minimum match cond was violated
                    if not self.sufficient_consumed(
                        sgroup_repetition, subgroup.quantifier
                    ):
                        # raise MinMatchesNotFound
                        return MatchResult(False)

                    sgroup_repetition = 0
                    # increment component pointer
                    sgptr += 1
            else:
                # quantifier restricts further consume
                # consider next subgroup
                sgptr += 1
                sgroup_repetition = 0
                continue

        # we want the pattern to be fully consumed and at least one
        # group has not been matched
        if last_matched_sgptr &lt; len(groups) - 1:
            return MatchResult(False)

        content = arr2str(matched)
        return MatchResult(True, content)

    def match_grouping(
        self, grouping: Grouping, string: str, stridx: int = 0
    ) -&gt; MatchResult:
        &#34;&#34;&#34;
        Finds the longest match by greedily matching characters.
        Greedy here implies, that when matching text on a sub-group, it will consume
        as many characters from the text, as the sub-group can match. This is
        noteworthy since a non-greedy sub-group match may result in a overall pattern match; whereas
        the greedy approach results in a non-match; e.g.:

        for pattern = (aa)*a, text = aaaa, the greedy algorithm would consider this a
        non-match since, the pattern must be fully consumed, and the final &#39;a&#39; does not get
        consumed.

        The user string may be partially consumed. However, if the pattern
        is not consumed, then this is considered a non-match.

        An empty string is a valid input to match. Further an empty string can
        match an arbitrary pattern, as long as each child pattern allows
        zero matches. Thus all matching handlers must handle zero-length input string

        Args:
            stridx: idx where to start matching string

        Returns:
            MatchResult.matched is True if there is a complete match; else False
        &#34;&#34;&#34;

        groups = grouping.groups

        group_repetition = 0  # count of repetitions of group
        matched = []  # chars that have matched
        sg_matched = True
        while self.can_consume(group_repetition, grouping.quantifier):
            res = self.match_sub_groups(groups, string, stridx)
            if res.matched:
                matched.append(res.content)
                group_repetition += 1
                stridx += len(res.content)
                if len(res.content) == 0:
                    break
            else:
                sg_matched = False
                break

        content = arr2str(matched)
        # the following distinguishes a non-match from an empty match
        # i.e. content length is 0 and the quantifier does not allow a zero match
        if (len(content) == 0 and sg_matched is False) and self.accepts_empty(
            grouping.quantifier
        ) is False:
            return MatchResult(False)

        return MatchResult(True, content)

    def match(self, string: str, stridx: int = 0) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Attempt to match `string` starting at `startidx`
        Args:
            string: string to match
            startidx: location to start search
        Return
            None: no-match
            str: match (possibly zero length)
        &#34;&#34;&#34;
        matched = None
        result = self.match_grouping(self.compiled, string, stridx)
        if result.matched:
            matched = result.content
        return matched</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="textwalker.pattern_parser.PatternMatcher.accepts_empty"><code class="name flex">
<span>def <span class="ident">accepts_empty</span></span>(<span>quantifier: <a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the quantifier allows for an empty match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def accepts_empty(quantifier: Quantifier) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether the quantifier allows for an empty match
    &#34;&#34;&#34;
    # TODO: add check for quantity range
    return isinstance(quantifier, ZeroOrMore) or isinstance(quantifier, ZeroOrOne)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher.can_consume"><code class="name flex">
<span>def <span class="ident">can_consume</span></span>(<span>to_run_iteration: int, quantifier: <a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the <code>quantifier</code> allows consuming another repetition
NOTE: this should be invoked before consuming</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def can_consume(to_run_iteration: int, quantifier: Quantifier) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether the `quantifier` allows consuming another repetition
    NOTE: this should be invoked before consuming
    &#34;&#34;&#34;
    if isinstance(quantifier, ZeroOrMore) or isinstance(quantifier, OneOrMore):
        return True
    elif isinstance(quantifier, ZeroOrOne):
        return to_run_iteration &lt; 1
    elif quantifier is None:
        # interpret None as 1
        return to_run_iteration &lt; 1
    return True</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher.match_charset"><code class="name flex">
<span>def <span class="ident">match_charset</span></span>(<span>charset: <a title="textwalker.pattern_parser.Charset" href="#textwalker.pattern_parser.Charset">Charset</a>, string: str, stridx: int = 0) ‑> <a title="textwalker.pattern_parser.MatchResult" href="#textwalker.pattern_parser.MatchResult">MatchResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to match a charset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def match_charset(charset: Charset, string: str, stridx: int = 0) -&gt; MatchResult:
    &#34;&#34;&#34;
    Attempt to match a charset
    &#34;&#34;&#34;
    for charset_member in charset.matches:
        if stridx == len(string):
            # handle empty string
            return MatchResult(False)
        if isinstance(charset_member, Literal):
            if charset_member.value == string[stridx]:
                return MatchResult(True, string[stridx])
        elif isinstance(charset_member, CharRange):
            # NOTE: this comparison relies on python&#39;s lexical ordering
            if (
                charset_member.range_start
                &lt;= string[stridx]
                &lt;= charset_member.range_end
            ):
                return MatchResult(True, string[stridx])
    return MatchResult(False)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher.match_literal"><code class="name flex">
<span>def <span class="ident">match_literal</span></span>(<span>literal: <a title="textwalker.pattern_parser.Literal" href="#textwalker.pattern_parser.Literal">Literal</a>, string: str, stridx: int = 0) ‑> <a title="textwalker.pattern_parser.MatchResult" href="#textwalker.pattern_parser.MatchResult">MatchResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to match a literal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def match_literal(literal: Literal, string: str, stridx: int = 0) -&gt; MatchResult:
    &#34;&#34;&#34;
    Attempt to match a literal
    &#34;&#34;&#34;
    for idx, lch in enumerate(literal.value):
        if stridx + idx == len(string):
            return MatchResult(False)
        if lch != string[stridx + idx]:
            return MatchResult(False)
    return MatchResult(True, literal.value)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher.sufficient_consumed"><code class="name flex">
<span>def <span class="ident">sufficient_consumed</span></span>(<span>last_repetition: int, quantifier: <a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the minimum number of elements was consumed
NOTE: this should be invoked after consuming</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sufficient_consumed(last_repetition: int, quantifier: Quantifier) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether the minimum number of elements was consumed
    NOTE: this should be invoked after consuming
    &#34;&#34;&#34;
    if isinstance(quantifier, ZeroOrOne):
        return True
    elif isinstance(quantifier, ZeroOrMore):
        return True
    elif isinstance(quantifier, OneOrMore):
        return last_repetition &gt;= 1
    elif quantifier is None:
        # TODO: not sure if this correct
        return True
    else:
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textwalker.pattern_parser.PatternMatcher.check_and_update_empty"><code class="name flex">
<span>def <span class="ident">check_and_update_empty</span></span>(<span>self, result: <a title="textwalker.pattern_parser.MatchResult" href="#textwalker.pattern_parser.MatchResult">MatchResult</a>, quantifier: <a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a>) ‑> <a title="textwalker.pattern_parser.MatchResult" href="#textwalker.pattern_parser.MatchResult">MatchResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>In cases where the quantifier, permits 0 matches, e.g. *, ?,
a "no-match" of a sub-group is to be treated as a match of length zero.</p>
<h2 id="returns">Returns</h2>
<p>If there is a no-match, and the quantifier allows zero matches,
then this will update the result to be an empty match;
Otherwise, it will return the <code>result</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_and_update_empty(
    self, result: MatchResult, quantifier: Quantifier
) -&gt; MatchResult:
    &#34;&#34;&#34;
    In cases where the quantifier, permits 0 matches, e.g. *, ?,
    a &#34;no-match&#34; of a sub-group is to be treated as a match of length zero.

    Returns:
        If there is a no-match, and the quantifier allows zero matches,
        then this will update the result to be an empty match;
        Otherwise, it will return the `result`
    &#34;&#34;&#34;
    # if quantifier is [0,..] and no-match, this is treated
    # as a match of len 0;
    if result.matched is False and self.accepts_empty(quantifier):
        result = MatchResult(True, &#34;&#34;)
    # else return original result
    return result</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, string: str, stridx: int = 0) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to match <code>string</code> starting at <code>startidx</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>string</code></strong></dt>
<dd>string to match</dd>
<dt><strong><code>startidx</code></strong></dt>
<dd>location to start search</dd>
</dl>
<p>Return
None: no-match
str: match (possibly zero length)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, string: str, stridx: int = 0) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Attempt to match `string` starting at `startidx`
    Args:
        string: string to match
        startidx: location to start search
    Return
        None: no-match
        str: match (possibly zero length)
    &#34;&#34;&#34;
    matched = None
    result = self.match_grouping(self.compiled, string, stridx)
    if result.matched:
        matched = result.content
    return matched</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher.match_grouping"><code class="name flex">
<span>def <span class="ident">match_grouping</span></span>(<span>self, grouping: <a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a>, string: str, stridx: int = 0) ‑> <a title="textwalker.pattern_parser.MatchResult" href="#textwalker.pattern_parser.MatchResult">MatchResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Finds the longest match by greedily matching characters.
Greedy here implies, that when matching text on a sub-group, it will consume
as many characters from the text, as the sub-group can match. This is
noteworthy since a non-greedy sub-group match may result in a overall pattern match; whereas
the greedy approach results in a non-match; e.g.:</p>
<p>for pattern = (aa)*a, text = aaaa, the greedy algorithm would consider this a
non-match since, the pattern must be fully consumed, and the final 'a' does not get
consumed.</p>
<p>The user string may be partially consumed. However, if the pattern
is not consumed, then this is considered a non-match.</p>
<p>An empty string is a valid input to match. Further an empty string can
match an arbitrary pattern, as long as each child pattern allows
zero matches. Thus all matching handlers must handle zero-length input string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stridx</code></strong></dt>
<dd>idx where to start matching string</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>MatchResult.matched is True if there is a complete match; else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_grouping(
    self, grouping: Grouping, string: str, stridx: int = 0
) -&gt; MatchResult:
    &#34;&#34;&#34;
    Finds the longest match by greedily matching characters.
    Greedy here implies, that when matching text on a sub-group, it will consume
    as many characters from the text, as the sub-group can match. This is
    noteworthy since a non-greedy sub-group match may result in a overall pattern match; whereas
    the greedy approach results in a non-match; e.g.:

    for pattern = (aa)*a, text = aaaa, the greedy algorithm would consider this a
    non-match since, the pattern must be fully consumed, and the final &#39;a&#39; does not get
    consumed.

    The user string may be partially consumed. However, if the pattern
    is not consumed, then this is considered a non-match.

    An empty string is a valid input to match. Further an empty string can
    match an arbitrary pattern, as long as each child pattern allows
    zero matches. Thus all matching handlers must handle zero-length input string

    Args:
        stridx: idx where to start matching string

    Returns:
        MatchResult.matched is True if there is a complete match; else False
    &#34;&#34;&#34;

    groups = grouping.groups

    group_repetition = 0  # count of repetitions of group
    matched = []  # chars that have matched
    sg_matched = True
    while self.can_consume(group_repetition, grouping.quantifier):
        res = self.match_sub_groups(groups, string, stridx)
        if res.matched:
            matched.append(res.content)
            group_repetition += 1
            stridx += len(res.content)
            if len(res.content) == 0:
                break
        else:
            sg_matched = False
            break

    content = arr2str(matched)
    # the following distinguishes a non-match from an empty match
    # i.e. content length is 0 and the quantifier does not allow a zero match
    if (len(content) == 0 and sg_matched is False) and self.accepts_empty(
        grouping.quantifier
    ) is False:
        return MatchResult(False)

    return MatchResult(True, content)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternMatcher.match_sub_groups"><code class="name flex">
<span>def <span class="ident">match_sub_groups</span></span>(<span>self, groups: List[<a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a>], string: str, stridx: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to match a list of sub groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_sub_groups(self, groups: List[Token], string: str, stridx: int = 0):
    &#34;&#34;&#34;
    Attempt to match a list of sub groups.
    &#34;&#34;&#34;
    sgptr = 0  # sub-group ptr
    sgroup_repetition = 0  # count of repetitions of current sub group
    matched = []
    # the last gptr location where a match was found
    # needed to determine if the pattern was fully consumed
    last_matched_sgptr = -1

    while sgptr &lt; len(groups):

        # there are 2 things to check:
        # 1) is there a match
        # 2) is the number of repetitions of match as expected

        # consume as much of string (maximum munch) using subgroup
        subgroup = groups[sgptr]

        # does the quantifier on this subgroup, allow it to consume more chars
        if self.can_consume(sgroup_repetition, subgroup.quantifier):

            # invoke the right handler
            res = None
            if isinstance(subgroup, Literal):
                res = self.match_literal(subgroup, string, stridx)
                res = self.check_and_update_empty(res, subgroup.quantifier)
            elif isinstance(subgroup, Charset):
                res = self.match_charset(subgroup, string, stridx)
                res = self.check_and_update_empty(res, subgroup.quantifier)
            else:
                assert isinstance(
                    subgroup, Grouping
                ), &#34;unexpected sub-expression type&#34;
                # groupings can be nested
                # so the matching algorithm must be recursive
                res = self.match_grouping(subgroup, string, stridx)
                res = self.check_and_update_empty(res, subgroup.quantifier)

            # current component matched
            if res.matched:
                sgroup_repetition += 1
                matched.append(res.content)
                # increment string pointer
                stridx += len(res.content)
                last_matched_sgptr = sgptr

                # increment the gptr; this represents
                # something not matching with [0,...] quantifier
                # we treat this as a match of length 0
                if len(res.content) == 0:
                    sgptr += 1
                    sgroup_repetition = 0

            # current component did not match
            else:
                # no match, move to next matchable
                # check minimum match cond was violated
                if not self.sufficient_consumed(
                    sgroup_repetition, subgroup.quantifier
                ):
                    # raise MinMatchesNotFound
                    return MatchResult(False)

                sgroup_repetition = 0
                # increment component pointer
                sgptr += 1
        else:
            # quantifier restricts further consume
            # consider next subgroup
            sgptr += 1
            sgroup_repetition = 0
            continue

    # we want the pattern to be fully consumed and at least one
    # group has not been matched
    if last_matched_sgptr &lt; len(groups) - 1:
        return MatchResult(False)

    content = arr2str(matched)
    return MatchResult(True, content)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textwalker.pattern_parser.PatternParser"><code class="flex name class">
<span>class <span class="ident">PatternParser</span></span>
<span>(</span><span>pattern: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class responsible for parsing logic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PatternParser:
    &#34;&#34;&#34;
    Class responsible for parsing logic.
    &#34;&#34;&#34;

    def __init__(self, pattern: str):
        # when parsing a chunk, `start` is the start of the chunk
        # and `current` points to the `current` char
        self.start = 0
        self.current = 0
        self.pattern = pattern
        self.compiled = None
        self.compile()

    def is_at_end(self) -&gt; bool:
        &#34;&#34;&#34;
        Determine whether parser is at the end of the pattern text
        &#34;&#34;&#34;
        return self.current &gt;= len(self.pattern)

    def advance(self) -&gt; str:
        &#34;&#34;&#34;
        Consume and return the current char.
        Consumption increments `current`
        &#34;&#34;&#34;
        char = self.pattern[self.current]
        self.current += 1
        return char

    def has_next(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether there is a next element to consume
        &#34;&#34;&#34;
        return self.current &lt; len(self.pattern) - 1

    def has_next_next(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines whether there is a next to next element to consume
        &#34;&#34;&#34;
        return self.current &lt; len(self.pattern) - 2

    def peek(self) -&gt; str:
        &#34;&#34;&#34;
        View the current element without consuming it
        &#34;&#34;&#34;
        return self.pattern[self.current]

    def peek_next(self) -&gt; str:
        &#34;&#34;&#34;
        View the next element without consuming it.
        NOTE: This call is only valid if `has_next` is True
        &#34;&#34;&#34;
        return self.pattern[self.current + 1]

    def peek_next_next(self) -&gt; str:
        &#34;&#34;&#34;
        View the next to next element without consuming it
        NOTE: This call is only valid if `has_next_next` is True
        &#34;&#34;&#34;
        return self.pattern[self.current + 2]

    @staticmethod
    def coalesce_literals(tokens: List[Token]) -&gt; List[Token]:
        &#34;&#34;&#34;
        Combine adjacent literal chars with no quantifier into a literal word;
        e.g. L[a]L[b] -&gt; L[ab]

        This is needed because the parsing pass, does not peek to the next
        char and treats each char as a single-char literal. This coalescing is needed
        to match word level repetitions.

        The relative ordering of non-`Literal` tokens and `Literal` tokens with
        quantifiers is unchanged.
        &#34;&#34;&#34;

        coalesced = []
        partials = (
            []
        )  # partial list of chars that will be coalesced into in a single Literal
        for idx, token in enumerate(tokens):
            # if quantifier is not None, can&#39;t coalesce into one literal
            if isinstance(token, Literal) and token.quantifier is None:
                partials.append(token)
            elif len(partials) &gt; 0:
                # we&#39;re at coalesce boundary; coalesce `partials` into a single
                # Literal and add to result
                value = &#34;&#34;.join([literal.value for literal in partials])
                coalesced.append(Literal(value))
                partials = []

            # add all other tokens, as-is
            if (
                not isinstance(token, Literal)
                or isinstance(token, Literal)
                and token.quantifier is not None
            ):
                coalesced.append(token)

        if len(partials) &gt; 0:
            # add remaining chars as a literal
            value = &#34;&#34;.join([literal.value for literal in partials])
            coalesced.append(Literal(value))
        return coalesced

    def compile(self):
        &#34;&#34;&#34;
        compile the user supplied pattern
        &#34;&#34;&#34;
        if self.compiled is None:
            self.compiled = self.compile_grouping()

    def compile_subgroups(self, subgroups: List[Token]) -&gt; Token:
        &#34;&#34;&#34;
        Compile subgroups.

        When compiling a pattern, a pattern may consist of
        one or more subgroups. If there is a single sub-group, return
        the subgroup as is. This is needed to avoid excessive nesting,
        which leads to incorrect behavior. If there are multiple sub-groups, then
        wrap them in a coalesced `Grouping`
        &#34;&#34;&#34;
        coalesced = self.coalesce_literals(subgroups)
        if len(coalesced) == 1:
            # return single sub group as is
            return coalesced.pop()
        # wrap multiple sub-groups in a grouping
        return Grouping(coalesced)

    def compile_grouping(self, is_nested: bool = False) -&gt; Grouping:
        &#34;&#34;&#34;
        Compile the pattern/grouping. A grouping consists of any number of
        literals, charsets, and sub-groups, and is the most general
        representation of a pattern. Hence, the user input is treated as a `Grouping`

        args:
            is_nested: whether this is nested grouping

        pattern can be of form:
        foo  : literal
        [a-z]: charset (range)
        [3-9]
        [az] charsets (enumeration)
        fox* : single-char quantifier: *,+,?
        [3-9]{3,4}: quantity/numeric range
        (foo)*: groupings
        (foo_[a-z]*)+: groupings

        NB: quantifiers can apply to any other element, except another quantifier

        special chars, namely:
            -, {, }, [, ], *, +, ?, (, ) must be escaped

        escape via backslash prepended to char

        An unescaped special char is an error

        An escaped char, that should not be escaped in an error.

        Returns:
            compiled grouping; for the root call this is a `Grouping`
            object; for a non-root call this could be any other `Token`
        &#34;&#34;&#34;
        compiled = []
        while self.is_at_end() is False:
            ch = self.advance()
            if ch == &#34;(&#34;:
                # handle grouping
                grouping = self.compile_grouping(is_nested=True)
                compiled.append(grouping)
            elif ch == &#34;)&#34;:
                if is_nested:
                    # this terminates the grouping
                    return self.compile_subgroups(compiled)
                raise UnescapedChar(&#34;)&#34;)
            elif ch == &#34;[&#34;:
                # this will either succeed and consume and return
                # entire charset, or raise exception
                charset = self.compile_charset()
                compiled.append(charset)
            # handle quantifiers
            elif ch == &#34;*&#34; or ch == &#34;+&#34; or ch == &#34;?&#34;:
                # find matchable to attach quantifier to
                matchable = compiled[-1] if len(compiled) &gt; 0 else None
                if matchable is None:
                    raise UnescapedChar
                if ch == &#34;*&#34;:
                    matchable.quantifier = ZeroOrMore()
                elif ch == &#34;+&#34;:
                    matchable.quantifier = OneOrMore()
                else:
                    assert ch == &#34;?&#34;, &#34;unknown quantifier&#34;
                    matchable.quantifier = ZeroOrOne()
            elif ch == &#34;{&#34;:
                # this will either succeed and consume the entire quantifier or raise
                # TODO: implememt me
                raise NotImplementedError
            # handle escape char
            elif ch == &#34;\\&#34;:
                next_char = self.advance()
                if next_char not in ESCAPABLE_CHARS:
                    # NOTE: currently not supporting all escape chars
                    raise UnrecognizedEscapedChar
                # add the escaped char as a literal
                compiled.append(Literal(next_char))

            else:
                compiled.append(Literal(ch))

        if is_nested:
            # this is error; since this was a nested call we should have found
            # a closing bracket; the choice of exception is imprecise
            # because the user&#39;s intention could be to: 1) create a group
            # and perhaps forgot the closing bracket; or 2) a literal match
            # on open bracket &#34;(&#34; and forgot to escape; for now bracket &#34;(&#34; must be escaped
            raise UnescapedChar(&#34;Unclosed bracket&#34;)

        grouping = self.compile_subgroups(compiled)
        if not is_nested and not isinstance(grouping, Grouping):
            # this is the root call- the returned must be wrapped in a grouping
            grouping = Grouping([grouping])
        return grouping

    def compile_charset(self) -&gt; Charset:
        &#34;&#34;&#34;
        Consume characters in the pattern, corresponding to a charset,
        i.e. started with &#39;[&#39;, terminated with &#39;]&#39; with literals and char ranges
        in between.

        Returns:
            compiled `Charset`

        Raises:
            - UnclosedSet and unescapedDash
        &#34;&#34;&#34;
        result = []
        closed = False  # whether the charset is closed
        while self.is_at_end() is False:
            ch = self.advance()  # consume char
            # handle escape char
            if ch == &#34;\\&#34;:
                next_char = self.advance()
                if next_char not in ESCAPABLE_CHARS:
                    # NOTE: currently not supporting all escape chars
                    raise UnrecognizedEscapedChar
                # add the escaped char as a literal
                result.append(Literal(next_char))

            # handle range dash
            if ch == &#34;-&#34;:
                # an unescaped dash, should only appear between a range
                # this simplifies the case, where it&#39;s the first or last char in set
                raise UnescapedDash
            if ch == &#34;]&#34;:
                # closing bracket found
                closed = True
                break
            else:  # ch is non-special
                # check if it&#39;s part of a range
                if self.has_next() and self.peek() == &#34;-&#34;:
                    if not self.has_next_next():
                        # unescaped dash&#39;s are only supported in range
                        raise UnescapedDash
                    self.advance()  # consume the dash
                    rng_end = self.advance()
                    rng = CharRange(ch, rng_end)
                    result.append(rng)
                else:  # handle literal
                    result.append(Literal(ch))
        if not closed:
            raise UnclosedCharSet()

        return Charset(result)

    def match(self, string: str, startidx: int = 0) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Attempt to match `string` starting at `startidx`
        Args:
            string: string to match
            startidx: location to start search
        Return
            None: no-match
            str: match (possibly zero length)
        &#34;&#34;&#34;
        matcher = PatternMatcher(self.compiled)
        return matcher.match(string, startidx)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="textwalker.pattern_parser.PatternParser.coalesce_literals"><code class="name flex">
<span>def <span class="ident">coalesce_literals</span></span>(<span>tokens: List[<a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a>]) ‑> List[<a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Combine adjacent literal chars with no quantifier into a literal word;
e.g. L[a]L[b] -&gt; L[ab]</p>
<p>This is needed because the parsing pass, does not peek to the next
char and treats each char as a single-char literal. This coalescing is needed
to match word level repetitions.</p>
<p>The relative ordering of non-<code><a title="textwalker.pattern_parser.Literal" href="#textwalker.pattern_parser.Literal">Literal</a></code> tokens and <code><a title="textwalker.pattern_parser.Literal" href="#textwalker.pattern_parser.Literal">Literal</a></code> tokens with
quantifiers is unchanged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def coalesce_literals(tokens: List[Token]) -&gt; List[Token]:
    &#34;&#34;&#34;
    Combine adjacent literal chars with no quantifier into a literal word;
    e.g. L[a]L[b] -&gt; L[ab]

    This is needed because the parsing pass, does not peek to the next
    char and treats each char as a single-char literal. This coalescing is needed
    to match word level repetitions.

    The relative ordering of non-`Literal` tokens and `Literal` tokens with
    quantifiers is unchanged.
    &#34;&#34;&#34;

    coalesced = []
    partials = (
        []
    )  # partial list of chars that will be coalesced into in a single Literal
    for idx, token in enumerate(tokens):
        # if quantifier is not None, can&#39;t coalesce into one literal
        if isinstance(token, Literal) and token.quantifier is None:
            partials.append(token)
        elif len(partials) &gt; 0:
            # we&#39;re at coalesce boundary; coalesce `partials` into a single
            # Literal and add to result
            value = &#34;&#34;.join([literal.value for literal in partials])
            coalesced.append(Literal(value))
            partials = []

        # add all other tokens, as-is
        if (
            not isinstance(token, Literal)
            or isinstance(token, Literal)
            and token.quantifier is not None
        ):
            coalesced.append(token)

    if len(partials) &gt; 0:
        # add remaining chars as a literal
        value = &#34;&#34;.join([literal.value for literal in partials])
        coalesced.append(Literal(value))
    return coalesced</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textwalker.pattern_parser.PatternParser.advance"><code class="name flex">
<span>def <span class="ident">advance</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Consume and return the current char.
Consumption increments <code>current</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advance(self) -&gt; str:
    &#34;&#34;&#34;
    Consume and return the current char.
    Consumption increments `current`
    &#34;&#34;&#34;
    char = self.pattern[self.current]
    self.current += 1
    return char</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>compile the user supplied pattern</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self):
    &#34;&#34;&#34;
    compile the user supplied pattern
    &#34;&#34;&#34;
    if self.compiled is None:
        self.compiled = self.compile_grouping()</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.compile_charset"><code class="name flex">
<span>def <span class="ident">compile_charset</span></span>(<span>self) ‑> <a title="textwalker.pattern_parser.Charset" href="#textwalker.pattern_parser.Charset">Charset</a></span>
</code></dt>
<dd>
<div class="desc"><p>Consume characters in the pattern, corresponding to a charset,
i.e. started with '[', terminated with ']' with literals and char ranges
in between.</p>
<h2 id="returns">Returns</h2>
<p>compiled <code><a title="textwalker.pattern_parser.Charset" href="#textwalker.pattern_parser.Charset">Charset</a></code></p>
<h2 id="raises">Raises</h2>
<ul>
<li>UnclosedSet and unescapedDash</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_charset(self) -&gt; Charset:
    &#34;&#34;&#34;
    Consume characters in the pattern, corresponding to a charset,
    i.e. started with &#39;[&#39;, terminated with &#39;]&#39; with literals and char ranges
    in between.

    Returns:
        compiled `Charset`

    Raises:
        - UnclosedSet and unescapedDash
    &#34;&#34;&#34;
    result = []
    closed = False  # whether the charset is closed
    while self.is_at_end() is False:
        ch = self.advance()  # consume char
        # handle escape char
        if ch == &#34;\\&#34;:
            next_char = self.advance()
            if next_char not in ESCAPABLE_CHARS:
                # NOTE: currently not supporting all escape chars
                raise UnrecognizedEscapedChar
            # add the escaped char as a literal
            result.append(Literal(next_char))

        # handle range dash
        if ch == &#34;-&#34;:
            # an unescaped dash, should only appear between a range
            # this simplifies the case, where it&#39;s the first or last char in set
            raise UnescapedDash
        if ch == &#34;]&#34;:
            # closing bracket found
            closed = True
            break
        else:  # ch is non-special
            # check if it&#39;s part of a range
            if self.has_next() and self.peek() == &#34;-&#34;:
                if not self.has_next_next():
                    # unescaped dash&#39;s are only supported in range
                    raise UnescapedDash
                self.advance()  # consume the dash
                rng_end = self.advance()
                rng = CharRange(ch, rng_end)
                result.append(rng)
            else:  # handle literal
                result.append(Literal(ch))
    if not closed:
        raise UnclosedCharSet()

    return Charset(result)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.compile_grouping"><code class="name flex">
<span>def <span class="ident">compile_grouping</span></span>(<span>self, is_nested: bool = False) ‑> <a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a></span>
</code></dt>
<dd>
<div class="desc"><p>Compile the pattern/grouping. A grouping consists of any number of
literals, charsets, and sub-groups, and is the most general
representation of a pattern. Hence, the user input is treated as a <code><a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a></code></p>
<p>args:
is_nested: whether this is nested grouping</p>
<p>pattern can be of form:
foo
: literal</p>
<p>[3-9]
[az] charsets (enumeration)
fox<em> : single-char quantifier: </em>,+,?
[3-9]{3,4}: quantity/numeric range
(foo)<em>: groupings
(foo_<a href="charset" title="range">a-z</a></em>)+: groupings</p>
<p>NB: quantifiers can apply to any other element, except another quantifier</p>
<p>special chars, namely:
-, {, }, [, ], *, +, ?, (, ) must be escaped</p>
<p>escape via backslash prepended to char</p>
<p>An unescaped special char is an error</p>
<p>An escaped char, that should not be escaped in an error.</p>
<h2 id="returns">Returns</h2>
<p>compiled grouping; for the root call this is a <code><a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a></code>
object; for a non-root call this could be any other <code><a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_grouping(self, is_nested: bool = False) -&gt; Grouping:
    &#34;&#34;&#34;
    Compile the pattern/grouping. A grouping consists of any number of
    literals, charsets, and sub-groups, and is the most general
    representation of a pattern. Hence, the user input is treated as a `Grouping`

    args:
        is_nested: whether this is nested grouping

    pattern can be of form:
    foo  : literal
    [a-z]: charset (range)
    [3-9]
    [az] charsets (enumeration)
    fox* : single-char quantifier: *,+,?
    [3-9]{3,4}: quantity/numeric range
    (foo)*: groupings
    (foo_[a-z]*)+: groupings

    NB: quantifiers can apply to any other element, except another quantifier

    special chars, namely:
        -, {, }, [, ], *, +, ?, (, ) must be escaped

    escape via backslash prepended to char

    An unescaped special char is an error

    An escaped char, that should not be escaped in an error.

    Returns:
        compiled grouping; for the root call this is a `Grouping`
        object; for a non-root call this could be any other `Token`
    &#34;&#34;&#34;
    compiled = []
    while self.is_at_end() is False:
        ch = self.advance()
        if ch == &#34;(&#34;:
            # handle grouping
            grouping = self.compile_grouping(is_nested=True)
            compiled.append(grouping)
        elif ch == &#34;)&#34;:
            if is_nested:
                # this terminates the grouping
                return self.compile_subgroups(compiled)
            raise UnescapedChar(&#34;)&#34;)
        elif ch == &#34;[&#34;:
            # this will either succeed and consume and return
            # entire charset, or raise exception
            charset = self.compile_charset()
            compiled.append(charset)
        # handle quantifiers
        elif ch == &#34;*&#34; or ch == &#34;+&#34; or ch == &#34;?&#34;:
            # find matchable to attach quantifier to
            matchable = compiled[-1] if len(compiled) &gt; 0 else None
            if matchable is None:
                raise UnescapedChar
            if ch == &#34;*&#34;:
                matchable.quantifier = ZeroOrMore()
            elif ch == &#34;+&#34;:
                matchable.quantifier = OneOrMore()
            else:
                assert ch == &#34;?&#34;, &#34;unknown quantifier&#34;
                matchable.quantifier = ZeroOrOne()
        elif ch == &#34;{&#34;:
            # this will either succeed and consume the entire quantifier or raise
            # TODO: implememt me
            raise NotImplementedError
        # handle escape char
        elif ch == &#34;\\&#34;:
            next_char = self.advance()
            if next_char not in ESCAPABLE_CHARS:
                # NOTE: currently not supporting all escape chars
                raise UnrecognizedEscapedChar
            # add the escaped char as a literal
            compiled.append(Literal(next_char))

        else:
            compiled.append(Literal(ch))

    if is_nested:
        # this is error; since this was a nested call we should have found
        # a closing bracket; the choice of exception is imprecise
        # because the user&#39;s intention could be to: 1) create a group
        # and perhaps forgot the closing bracket; or 2) a literal match
        # on open bracket &#34;(&#34; and forgot to escape; for now bracket &#34;(&#34; must be escaped
        raise UnescapedChar(&#34;Unclosed bracket&#34;)

    grouping = self.compile_subgroups(compiled)
    if not is_nested and not isinstance(grouping, Grouping):
        # this is the root call- the returned must be wrapped in a grouping
        grouping = Grouping([grouping])
    return grouping</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.compile_subgroups"><code class="name flex">
<span>def <span class="ident">compile_subgroups</span></span>(<span>self, subgroups: List[<a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a>]) ‑> <a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a></span>
</code></dt>
<dd>
<div class="desc"><p>Compile subgroups.</p>
<p>When compiling a pattern, a pattern may consist of
one or more subgroups. If there is a single sub-group, return
the subgroup as is. This is needed to avoid excessive nesting,
which leads to incorrect behavior. If there are multiple sub-groups, then
wrap them in a coalesced <code><a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_subgroups(self, subgroups: List[Token]) -&gt; Token:
    &#34;&#34;&#34;
    Compile subgroups.

    When compiling a pattern, a pattern may consist of
    one or more subgroups. If there is a single sub-group, return
    the subgroup as is. This is needed to avoid excessive nesting,
    which leads to incorrect behavior. If there are multiple sub-groups, then
    wrap them in a coalesced `Grouping`
    &#34;&#34;&#34;
    coalesced = self.coalesce_literals(subgroups)
    if len(coalesced) == 1:
        # return single sub group as is
        return coalesced.pop()
    # wrap multiple sub-groups in a grouping
    return Grouping(coalesced)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.has_next"><code class="name flex">
<span>def <span class="ident">has_next</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether there is a next element to consume</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_next(self) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether there is a next element to consume
    &#34;&#34;&#34;
    return self.current &lt; len(self.pattern) - 1</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.has_next_next"><code class="name flex">
<span>def <span class="ident">has_next_next</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether there is a next to next element to consume</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_next_next(self) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether there is a next to next element to consume
    &#34;&#34;&#34;
    return self.current &lt; len(self.pattern) - 2</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.is_at_end"><code class="name flex">
<span>def <span class="ident">is_at_end</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determine whether parser is at the end of the pattern text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_at_end(self) -&gt; bool:
    &#34;&#34;&#34;
    Determine whether parser is at the end of the pattern text
    &#34;&#34;&#34;
    return self.current &gt;= len(self.pattern)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, string: str, startidx: int = 0) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to match <code>string</code> starting at <code>startidx</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>string</code></strong></dt>
<dd>string to match</dd>
<dt><strong><code>startidx</code></strong></dt>
<dd>location to start search</dd>
</dl>
<p>Return
None: no-match
str: match (possibly zero length)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, string: str, startidx: int = 0) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Attempt to match `string` starting at `startidx`
    Args:
        string: string to match
        startidx: location to start search
    Return
        None: no-match
        str: match (possibly zero length)
    &#34;&#34;&#34;
    matcher = PatternMatcher(self.compiled)
    return matcher.match(string, startidx)</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>View the current element without consuming it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self) -&gt; str:
    &#34;&#34;&#34;
    View the current element without consuming it
    &#34;&#34;&#34;
    return self.pattern[self.current]</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.peek_next"><code class="name flex">
<span>def <span class="ident">peek_next</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>View the next element without consuming it.
NOTE: This call is only valid if <code>has_next</code> is True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek_next(self) -&gt; str:
    &#34;&#34;&#34;
    View the next element without consuming it.
    NOTE: This call is only valid if `has_next` is True
    &#34;&#34;&#34;
    return self.pattern[self.current + 1]</code></pre>
</details>
</dd>
<dt id="textwalker.pattern_parser.PatternParser.peek_next_next"><code class="name flex">
<span>def <span class="ident">peek_next_next</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>View the next to next element without consuming it
NOTE: This call is only valid if <code>has_next_next</code> is True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek_next_next(self) -&gt; str:
    &#34;&#34;&#34;
    View the next to next element without consuming it
    NOTE: This call is only valid if `has_next_next` is True
    &#34;&#34;&#34;
    return self.pattern[self.current + 2]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textwalker.pattern_parser.Quantifier"><code class="flex name class">
<span>class <span class="ident">Quantifier</span></span>
</code></dt>
<dd>
<div class="desc"><p>base quantifier class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Quantifier:
    &#34;&#34;&#34;
    base quantifier class
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.OneOrMore" href="#textwalker.pattern_parser.OneOrMore">OneOrMore</a></li>
<li><a title="textwalker.pattern_parser.ZeroOrMore" href="#textwalker.pattern_parser.ZeroOrMore">ZeroOrMore</a></li>
<li><a title="textwalker.pattern_parser.ZeroOrOne" href="#textwalker.pattern_parser.ZeroOrOne">ZeroOrOne</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.Token"><code class="flex name class">
<span>class <span class="ident">Token</span></span>
<span>(</span><span>quantifier=None)</span>
</code></dt>
<dd>
<div class="desc"><p>base token type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Token:
    &#34;&#34;&#34;
    base token type
    &#34;&#34;&#34;

    def __init__(self, quantifier=None):
        self.quantifier = quantifier</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.CharRange" href="#textwalker.pattern_parser.CharRange">CharRange</a></li>
<li><a title="textwalker.pattern_parser.Charset" href="#textwalker.pattern_parser.Charset">Charset</a></li>
<li><a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a></li>
<li><a title="textwalker.pattern_parser.Literal" href="#textwalker.pattern_parser.Literal">Literal</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.UnclosedCharSet"><code class="flex name class">
<span>class <span class="ident">UnclosedCharSet</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A char set was not closed, i.e. missing ']'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnclosedCharSet(Exception):
    &#34;&#34;&#34;
    A char set was not closed, i.e. missing &#39;]&#39;
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.UnescapedChar"><code class="flex name class">
<span>class <span class="ident">UnescapedChar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>These represent the constraint that special chars be escaped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnescapedChar(Exception):
    &#34;&#34;&#34;
    These represent the constraint that special chars be escaped
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.UnescapedDash" href="#textwalker.pattern_parser.UnescapedDash">UnescapedDash</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.UnescapedDash"><code class="flex name class">
<span>class <span class="ident">UnescapedDash</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A dash character was unescaped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnescapedDash(UnescapedChar):
    &#34;&#34;&#34;
    A dash character was unescaped
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.UnescapedChar" href="#textwalker.pattern_parser.UnescapedChar">UnescapedChar</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.UnrecognizedEscapedChar"><code class="flex name class">
<span>class <span class="ident">UnrecognizedEscapedChar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This represents that random characters should not be escaped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnrecognizedEscapedChar(Exception):
    &#34;&#34;&#34;
    This represents that random characters should not be escaped
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.ZeroOrMore"><code class="flex name class">
<span>class <span class="ident">ZeroOrMore</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents quantifier zero or more repetitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZeroOrMore(Quantifier):
    &#34;&#34;&#34;
    Represents quantifier zero or more repetitions
    &#34;&#34;&#34;

    def __str__(self):
        return &#34;*&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a></li>
</ul>
</dd>
<dt id="textwalker.pattern_parser.ZeroOrOne"><code class="flex name class">
<span>class <span class="ident">ZeroOrOne</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents quantifier zero or one repetitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZeroOrOne(Quantifier):
    &#34;&#34;&#34;
    Represents quantifier zero or one repetitions
    &#34;&#34;&#34;

    def __str__(self):
        return &#34;?&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textwalker.pattern_parser.CharRange" href="#textwalker.pattern_parser.CharRange">CharRange</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.Charset" href="#textwalker.pattern_parser.Charset">Charset</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.Grouping" href="#textwalker.pattern_parser.Grouping">Grouping</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.Literal" href="#textwalker.pattern_parser.Literal">Literal</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.MatchResult" href="#textwalker.pattern_parser.MatchResult">MatchResult</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.OneOrMore" href="#textwalker.pattern_parser.OneOrMore">OneOrMore</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.PatternMatcher" href="#textwalker.pattern_parser.PatternMatcher">PatternMatcher</a></code></h4>
<ul class="">
<li><code><a title="textwalker.pattern_parser.PatternMatcher.accepts_empty" href="#textwalker.pattern_parser.PatternMatcher.accepts_empty">accepts_empty</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.can_consume" href="#textwalker.pattern_parser.PatternMatcher.can_consume">can_consume</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.check_and_update_empty" href="#textwalker.pattern_parser.PatternMatcher.check_and_update_empty">check_and_update_empty</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.match" href="#textwalker.pattern_parser.PatternMatcher.match">match</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.match_charset" href="#textwalker.pattern_parser.PatternMatcher.match_charset">match_charset</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.match_grouping" href="#textwalker.pattern_parser.PatternMatcher.match_grouping">match_grouping</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.match_literal" href="#textwalker.pattern_parser.PatternMatcher.match_literal">match_literal</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.match_sub_groups" href="#textwalker.pattern_parser.PatternMatcher.match_sub_groups">match_sub_groups</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternMatcher.sufficient_consumed" href="#textwalker.pattern_parser.PatternMatcher.sufficient_consumed">sufficient_consumed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.PatternParser" href="#textwalker.pattern_parser.PatternParser">PatternParser</a></code></h4>
<ul class="two-column">
<li><code><a title="textwalker.pattern_parser.PatternParser.advance" href="#textwalker.pattern_parser.PatternParser.advance">advance</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.coalesce_literals" href="#textwalker.pattern_parser.PatternParser.coalesce_literals">coalesce_literals</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.compile" href="#textwalker.pattern_parser.PatternParser.compile">compile</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.compile_charset" href="#textwalker.pattern_parser.PatternParser.compile_charset">compile_charset</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.compile_grouping" href="#textwalker.pattern_parser.PatternParser.compile_grouping">compile_grouping</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.compile_subgroups" href="#textwalker.pattern_parser.PatternParser.compile_subgroups">compile_subgroups</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.has_next" href="#textwalker.pattern_parser.PatternParser.has_next">has_next</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.has_next_next" href="#textwalker.pattern_parser.PatternParser.has_next_next">has_next_next</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.is_at_end" href="#textwalker.pattern_parser.PatternParser.is_at_end">is_at_end</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.match" href="#textwalker.pattern_parser.PatternParser.match">match</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.peek" href="#textwalker.pattern_parser.PatternParser.peek">peek</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.peek_next" href="#textwalker.pattern_parser.PatternParser.peek_next">peek_next</a></code></li>
<li><code><a title="textwalker.pattern_parser.PatternParser.peek_next_next" href="#textwalker.pattern_parser.PatternParser.peek_next_next">peek_next_next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.Quantifier" href="#textwalker.pattern_parser.Quantifier">Quantifier</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.Token" href="#textwalker.pattern_parser.Token">Token</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.UnclosedCharSet" href="#textwalker.pattern_parser.UnclosedCharSet">UnclosedCharSet</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.UnescapedChar" href="#textwalker.pattern_parser.UnescapedChar">UnescapedChar</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.UnescapedDash" href="#textwalker.pattern_parser.UnescapedDash">UnescapedDash</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.UnrecognizedEscapedChar" href="#textwalker.pattern_parser.UnrecognizedEscapedChar">UnrecognizedEscapedChar</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.ZeroOrMore" href="#textwalker.pattern_parser.ZeroOrMore">ZeroOrMore</a></code></h4>
</li>
<li>
<h4><code><a title="textwalker.pattern_parser.ZeroOrOne" href="#textwalker.pattern_parser.ZeroOrOne">ZeroOrOne</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>